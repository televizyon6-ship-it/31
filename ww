--------------------------------------------------------------------------------
-- Tower of Hell | Auto-Complete Script (Rewritten)
-- Anti-Float: Jump arc simulation, ground-verification raycasting, no raw CFrame tween
--------------------------------------------------------------------------------

-- Prevent double execution
if getgenv().TOH_LOADED then return end
pcall(function() getgenv().TOH_LOADED = true end)

local TweenService    = game:GetService("TweenService")
local Players         = game:GetService("Players")
local RunService      = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local VirtualUser     = game:GetService("VirtualUser")

local LP = Players.LocalPlayer
local Char, Hum, Root

local function refreshChar(char)
    Char = char or LP.Character
    Hum  = Char and Char:WaitForChild("Humanoid")
    Root = Char and Char:WaitForChild("HumanoidRootPart")
end

refreshChar(LP.Character or LP.CharacterAdded:Wait())
LP.CharacterAdded:Connect(refreshChar)

--------------------------------------------------------------------------------
-- Auto-queue on teleport
--------------------------------------------------------------------------------
local SCRIPT_URL   = "https://raw.githubusercontent.com/televizyon6-ship-it/31/refs/heads/main/ww"
local queueTeleport = queue_on_teleport or queueonteleport
    or (syn and syn.queue_on_teleport)
    or (fluxus and fluxus.queue_on_teleport)

if type(queueTeleport) == "function" then
    pcall(queueTeleport, ('loadstring(game:HttpGet("%s"))()'):format(SCRIPT_URL))
    print("[ToH] Queued for next server.")
end

-- Anti-AFK
LP.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

--------------------------------------------------------------------------------
-- Config
--------------------------------------------------------------------------------
local CFG = {
    -- Movement
    TweenSpeed        = 28,      -- Stud/s for tweens (horizontal speed)
    ArcHeight         = 6,       -- Peak height of simulated jump arc
    ArcSteps          = 20,      -- Keyframes per arc (more = smoother, heavier)
    StepDelay         = 0.02,    -- Seconds between arc keyframes

    -- Safety
    MaxHopDist        = 60,      -- Max stud gap to bridge in one hop
    MinHopDist        = 3,       -- Ignore parts closer than this
    FloatLeniency     = 0.3,     -- Extra seconds to "land" before next move
    GroundSnapOffset  = 4.2,     -- How far above a part's surface to hover (char height)

    -- Kill-part detection
    KillNames         = {"kill", "lava", "acid", "spike", "death", "drown"},
    KillNeon          = true,    -- Treat neon red/orange as kill parts

    -- Misc
    RunLoopDelay      = 1,       -- Seconds between run-loop ticks
    PostRunWait       = 10,      -- Wait after completing/resetting before next cycle
    SpawnMaxY         = 60,      -- Y threshold to consider "at spawn / bottom"
}

--------------------------------------------------------------------------------
-- Utility
--------------------------------------------------------------------------------
local function wait(t)
    local s = tick()
    repeat RunService.Heartbeat:Wait() until tick() - s >= (t or 0)
end

local function randomOffset(range)
    return Vector3.new(
        math.random(-range*10, range*10)/10,
        0,
        math.random(-range*10, range*10)/10
    )
end

-- Raycast downward from pos, returns hit position or nil
local RaycastParams_down = RaycastParams.new()
RaycastParams_down.FilterType = Enum.RaycastFilterType.Exclude

local function groundBelow(pos, charParts)
    RaycastParams_down.FilterDescendantsInstances = charParts or {}
    local result = workspace:Raycast(pos, Vector3.new(0, -200, 0), RaycastParams_down)
    if result then return result.Position end
    return nil
end

-- Is a part dangerous?
local function isKillPart(part)
    if not part:IsA("BasePart") then return false end
    local name = part.Name:lower()
    for _, kw in ipairs(CFG.KillNames) do
        if name:find(kw) then return true end
    end
    if CFG.KillNeon and part.Material == Enum.Material.Neon then
        local r, g, b = part.Color.R, part.Color.G, part.Color.B
        if r > 0.85 and g < 0.25 then return true end -- red/orange neon
    end
    return false
end

-- Is it safe to stand on?
local function isSafe(part)
    if not part:IsA("BasePart") then return false end
    if not part.CanCollide then return false end
    if part.Transparency >= 0.9 then return false end
    if isKillPart(part) then return false end
    return true
end

--------------------------------------------------------------------------------
-- Core Movement: Simulated Jump Arc (anti-float)
-- Instead of a direct tween through air, we compute a parabolic arc so the
-- player accelerates up then down — matching how real jumps look to the server.
--------------------------------------------------------------------------------
local function killForces()
    if not Root then return end
    for _, v in ipairs(Root:GetChildren()) do
        if v:IsA("BodyMover") then v:Destroy() end
    end
end

-- Briefly pin character so it stops drifting between moves
local function pinRoot()
    if not Root then return end
    killForces()
    local bv = Instance.new("BodyVelocity")
    bv.Velocity  = Vector3.zero
    bv.MaxForce  = Vector3.new(1e5, 1e5, 1e5)
    bv.Parent    = Root
    return bv
end

-- Move via arc keyframes between two world positions
-- targetPos should be the destination *surface* (we handle the Y offset internally)
local function arcMove(targetPos, heightBoost)
    if not Root then return end
    
    local height = heightBoost or CFG.ArcHeight
    local steps  = CFG.ArcSteps
    local delay  = CFG.StepDelay

    local startPos = Root.Position
    local endPos   = targetPos

    -- Calculate horizontal distance to decide arc height scaling
    local hDist = (Vector3.new(endPos.X, 0, endPos.Z) - Vector3.new(startPos.X, 0, startPos.Z)).Magnitude
    -- Short hops don't need a big arc
    local arcScale = math.clamp(hDist / 20, 0.4, 1.0)
    local arcH     = height * arcScale

    killForces()

    local bp = Instance.new("BodyPosition")
    bp.MaxForce  = Vector3.new(1e5, 1e5, 1e5)
    bp.D         = 500
    bp.P         = 5000
    bp.Parent    = Root

    local bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bg.D         = 400
    bg.CFrame    = CFrame.new(startPos, endPos) -- face direction of travel
    bg.Parent    = Root

    for i = 1, steps do
        local t = i / steps
        -- Lerp X/Z linearly, Y follows a sine arc (0 → peak → 0 extra height)
        local lerpPos = startPos:Lerp(endPos, t)
        local yArc    = arcH * math.sin(math.pi * t)

        bp.Position = Vector3.new(lerpPos.X, lerpPos.Y + yArc, lerpPos.Z)
        wait(delay)

        -- Bail early if we died
        if not Hum or Hum.Health <= 0 then
            killForces()
            return
        end
    end

    -- Snap to exact destination
    bp.Position = endPos

    -- Wait for physics to settle us on the surface
    wait(CFG.FloatLeniency)
    killForces()

    -- Zero residual velocity
    local bv = pinRoot()
    wait(0.08)
    if bv and bv.Parent then bv:Destroy() end
end

-- Shorter/same-level move without a big arc (walking equivalent)
local function slideMove(targetPos)
    arcMove(targetPos, 1.5) -- tiny arc just to avoid floating in place
end

--------------------------------------------------------------------------------
-- Part Collection & Sorting
--------------------------------------------------------------------------------
local function getCharParts()
    local t = {}
    if Char then for _, v in ipairs(Char:GetDescendants()) do if v:IsA("BasePart") then t[#t+1] = v end end end
    return t
end

local function getSafeParts(container)
    local parts = {}
    for _, d in ipairs(container:GetDescendants()) do
        if isSafe(d) then parts[#parts+1] = d end
    end
    table.sort(parts, function(a, b) return a.Position.Y < b.Position.Y end)
    return parts
end

-- Given a sorted list of parts, produce a minimal hop chain from startY to endY
-- Skips parts that are too close, merges when gap is fine
local function buildHopChain(parts, fromY, toY)
    local chain = {}
    local lastPos = Root.Position

    for _, p in ipairs(parts) do
        local py = p.Position.Y + CFG.GroundSnapOffset
        if py <= fromY then continue end
        if py > toY + CFG.GroundSnapOffset + 10 then break end

        local dist = (p.Position - lastPos).Magnitude
        if dist < CFG.MinHopDist then continue end

        -- If gap is too big, we must include this node as a bridge
        -- If gap is normal, include it anyway (looks natural, avoids float)
        if dist <= CFG.MaxHopDist then
            local landPos = Vector3.new(p.Position.X, p.Position.Y + CFG.GroundSnapOffset, p.Position.Z)
                + randomOffset(0.4) -- tiny random offset per node, looks human
            chain[#chain+1] = landPos
            lastPos = p.Position
        else
            -- Gap too large: try to find intermediate nodes already in chain or skip
            -- (If truly no bridge exists, we do a long arc anyway)
            local landPos = Vector3.new(p.Position.X, p.Position.Y + CFG.GroundSnapOffset, p.Position.Z)
            chain[#chain+1] = landPos
            lastPos = p.Position
        end
    end

    return chain
end

--------------------------------------------------------------------------------
-- Disable Character Collision (so we don't snag on geometry)
--------------------------------------------------------------------------------
local function setCharCollision(enabled)
    if not Char then return end
    for _, v in ipairs(Char:GetDescendants()) do
        if v:IsA("BasePart") then
            v.CanCollide = enabled
        end
    end
end

--------------------------------------------------------------------------------
-- Main Run Logic
--------------------------------------------------------------------------------
local function runTower()
    local Tower    = workspace:FindFirstChild("tower")
    local Sections = Tower and Tower:FindFirstChild("sections")

    if not Tower or not Sections then
        warn("[ToH] Could not find tower/sections in workspace.")
        return
    end

    print("[ToH] Tower found. Starting run...")
    setCharCollision(false)

    -- Build sorted section list
    local sectionList = {}
    for _, sec in ipairs(Sections:GetChildren()) do
        local startP = sec:FindFirstChild("start")
        local stopP  = sec:FindFirstChild("stop")
        local yRef   = 0
        if startP then
            yRef = startP.Position.Y
        elseif stopP then
            yRef = stopP.Position.Y
        else
            local parts = getSafeParts(sec)
            if #parts > 0 then yRef = parts[1].Position.Y end
        end
        sectionList[#sectionList+1] = {
            instance = sec,
            y        = yRef,
            startP   = startP,
            stopP    = stopP,
        }
    end

    table.sort(sectionList, function(a, b) return a.y < b.y end)

    -- Traverse each section
    for i, sd in ipairs(sectionList) do
        if not Root or (Hum and Hum.Health <= 0) then break end

        print(("[ToH] Section %d/%d — %s"):format(i, #sectionList, sd.instance.Name))

        -- 1. Travel to section start
        if sd.startP then
            local dest = sd.startP.Position + Vector3.new(0, CFG.GroundSnapOffset, 0)
            local dist = (Root.Position - dest).Magnitude
            if dist > CFG.MinHopDist then
                if dist <= 15 then slideMove(dest) else arcMove(dest) end
            end
        end

        -- 2. Hop through safe parts upward
        local fromY = Root.Position.Y
        local toY   = sd.stopP and sd.stopP.Position.Y
                    or (getSafeParts(sd.instance)[1] and select(2,({pcall(function()
                            local p = getSafeParts(sd.instance)
                            return p[#p] and p[#p].Position.Y or fromY + 200
                        end)})) or fromY + 200)

        -- Safer: just use stopP or a big Y window
        toY = sd.stopP and (sd.stopP.Position.Y + 5) or (fromY + 300)

        local parts = getSafeParts(sd.instance)
        local chain = buildHopChain(parts, fromY - 5, toY)

        for _, nodePos in ipairs(chain) do
            if not Root or (Hum and Hum.Health <= 0) then break end
            local dist = (Root.Position - nodePos).Magnitude
            if dist < CFG.MinHopDist then continue end

            if dist <= 18 then
                slideMove(nodePos)
            else
                arcMove(nodePos)
            end
        end

        -- 3. Travel to section stop
        if sd.stopP then
            local dest = sd.stopP.Position + Vector3.new(0, CFG.GroundSnapOffset, 0)
            local dist = (Root.Position - dest).Magnitude
            if dist > CFG.MinHopDist then
                if dist <= 15 then slideMove(dest) else arcMove(dest) end
            end
        end
    end

    -- Check for a finish part anywhere in tower
    local function findFinish(root)
        return root:FindFirstChild("finish", true)
            or root:FindFirstChild("FinishLine", true)
            or root:FindFirstChild("End", true)
    end

    local finishContainer = findFinish(Sections) or findFinish(Tower)
    if finishContainer then
        print("[ToH] Approaching finish...")
        local finishPos = finishContainer:IsA("BasePart")
            and finishContainer.Position
            or (finishContainer:FindFirstChildWhichIsA("BasePart") and
                finishContainer:FindFirstChildWhichIsA("BasePart").Position)

        if finishPos then
            arcMove(finishPos + Vector3.new(0, CFG.GroundSnapOffset, 0))
        end

        -- Fire touch events for any Touched-based finish triggers
        if firetouchinterest and finishContainer:IsA("BasePart") then
            firetouchinterest(Root, finishContainer, 0)
            wait(0.1)
            firetouchinterest(Root, finishContainer, 1)
        end
    end

    print("[ToH] Run complete! Resetting...")
    wait(1.5)

    -- Re-enable collision before reset so respawn is clean
    setCharCollision(true)
    if Hum then Hum.Health = 0 end

    wait(CFG.PostRunWait)

    -- Teleport to Pro Mode lobby
    print("[ToH] Teleporting to Pro Mode...")
    local ok, err = pcall(TeleportService.Teleport, TeleportService, 3582763398, LP)
    if not ok then warn("[ToH] Teleport failed: " .. tostring(err)) end
end

--------------------------------------------------------------------------------
-- Run Loop
--------------------------------------------------------------------------------
task.spawn(function()
    while true do
        wait(CFG.RunLoopDelay)

        refreshChar()
        if not Root then continue end

        local atSpawn = Root.Position.Y < CFG.SpawnMaxY
        if atSpawn then
            -- Small delay so the server has a moment to init
            wait(2)
            local ok, err = pcall(runTower)
            if not ok then
                warn("[ToH] Run error: " .. tostring(err))
                setCharCollision(true) -- safety restore
                killForces()
            end
            wait(CFG.PostRunWait)
        end
    end
end)

print("[ToH] Script loaded.")
